use crate::{
    Fp4,
    rosenhain::Rosenhain,
    theta::{compute_twoisogeny, theta_to_rosenhain, Theta},
};

/// Generate the default starting curve for hashing.
///
/// The curve is obtained by first calling `generate_init_curve` and then
/// applying the 0-th (2,2)-isogeny ten consecutive times.
pub fn generate_hash_init_curve<const p: u64, const D1: u64, const D2C0: u64, const D2C1: u64>() -> Rosenhain<p, D1, D2C0, D2C1> {
    let i = (-Fp4::<p, D1, D2C0, D2C1>::one())
        .sqrt()
        .expect("sqrt of -1 should exist in Fp4");

    let mut theta = Theta::<p, D1, D2C0, D2C1>::new(
        Rosenhain::<p, D1, D2C0, D2C1>::generate_init_curve(),
    );

    for _ in 0..10 {
        let new_null = compute_twoisogeny::<p, D1, D2C0, D2C1>(&theta.null, 0, i);
        theta = Theta { null: new_null };
    }

    theta_to_rosenhain::<p, D1, D2C0, D2C1>(&theta.null)
}

/// Convenience macro to compute `LTZ_hash` with automatically selected
/// quadratic extension parameters.
///
/// Given a prime `p` and a message `m`, this macro determines suitable
/// non-residues `D1` and `D2` for constructing `Fp4` and computes a
/// square root of `-1` in that field.  The `LTZ_hash` function is then
/// invoked with these parameters.
#[macro_export]
macro_rules! LTZ_hash_auto {
    ($p:expr, $m:expr) => {{
        const D1: u64 = $crate::find_non_residue($p);
        const D2: $crate::Cf2 = $crate::find_non_residue_fp2($p, D1);
        let i = (-$crate::Fp4::<$p, D1, { D2.c0 }, { D2.c1 }>::one())
            .sqrt()
            .expect("sqrt -1");
        let init = $crate::hash::generate_hash_init_curve::<$p, D1, { D2.c0 }, { D2.c1 }>();
        $crate::hash::LTZ_hash_with_init::<$p, D1, { D2.c0 }, { D2.c1 }>(i, $m, init)
    }};
}

/// Convenience macro to compute `LTZ_hash_with_init` with automatically selected
/// quadratic extension parameters and user supplied Rosenhain coefficients.
#[macro_export]
macro_rules! LTZ_hash_auto_with_init {
    ($p:expr, $la:expr, $mu:expr, $nu:expr, $m:expr) => {{
        const D1: u64 = $crate::find_non_residue($p);
        const D2: $crate::Cf2 = $crate::find_non_residue_fp2($p, D1);
        let i = (-$crate::Fp4::<$p, D1, { D2.c0 }, { D2.c1 }>::one())
            .sqrt()
            .expect("sqrt -1");
        let init = $crate::rosenhain::Rosenhain::<$p, D1, { D2.c0 }, { D2.c1 }>::new(
            $la, $mu, $nu,
        );
        $crate::hash::LTZ_hash_with_init::<$p, D1, { D2.c0 }, { D2.c1 }>(i, $m, init)
    }};
}

/// Compute Igusa invariants by iterating (2,2)-isogenies according to a bitstring.
///
/// `i` should be a square root of `-1` in `Fp4`.
/// The message `m` is read three bits at a time to select one of eight
/// isogenies. The final Igusa invariants are returned as a triple.
pub fn LTZ_hash<const p: u64, const D1: u64, const D2C0: u64, const D2C1: u64>(
    i: Fp4<p, D1, D2C0, D2C1>,
    m: &str,
) -> (
    Fp4<p, D1, D2C0, D2C1>,
    Fp4<p, D1, D2C0, D2C1>,
    Fp4<p, D1, D2C0, D2C1>,
) {
    // Initial curve isomorphic to y^2 = x^5 + 1
    let ram = Rosenhain::<p, D1, D2C0, D2C1>::generate_init_curve();
    LTZ_hash_with_init::<p, D1, D2C0, D2C1>(i, m, ram)
}

/// Version of `LTZ_hash` that accepts an explicit starting curve.
pub fn LTZ_hash_with_init<const p: u64, const D1: u64, const D2C0: u64, const D2C1: u64>(
    i: Fp4<p, D1, D2C0, D2C1>,
    m: &str,
    init: Rosenhain<p, D1, D2C0, D2C1>,
) -> (
    Fp4<p, D1, D2C0, D2C1>,
    Fp4<p, D1, D2C0, D2C1>,
    Fp4<p, D1, D2C0, D2C1>,
) {
    // Convert Rosenhain invariants to a squared theta null point
    let mut theta = Theta::<p, D1, D2C0, D2C1>::new(init);

    // Iterate through the message represented as octal characters.
    // Each digit directly selects one of the eight isogenies.
    for ch in m.chars() {
        if let Some(digit) = ch.to_digit(8) {
            let new_null =
                compute_twoisogeny::<p, D1, D2C0, D2C1>(&theta.null, digit as usize, i);
            theta = Theta { null: new_null };
        }
    }

    let ram = theta_to_rosenhain::<p, D1, D2C0, D2C1>(&theta.null);
    ram.IgusaInvariants()
}

/// Recover the message that yields a sequence of Igusa invariants.
///
/// `invariants` should start with the invariants of the default hashing curve
/// generated by [`generate_hash_init_curve`]. Each subsequent element must be
/// obtained by applying one of the eight (2,2)-isogenies indexed by `0..=7`.
/// The returned octal string encodes a message whose hash traverses the
/// same sequence of isogenies.
pub fn invariants_to_message<const p: u64, const D1: u64, const D2C0: u64, const D2C1: u64>(
    invariants: &[(
        Fp4<p, D1, D2C0, D2C1>,
        Fp4<p, D1, D2C0, D2C1>,
        Fp4<p, D1, D2C0, D2C1>,
    )],
) -> String {
    if invariants.is_empty() {
        return String::new();
    }

    // Generate the default starting curve and verify the first invariants.
    let init = generate_hash_init_curve::<p, D1, D2C0, D2C1>();
    let start_inv = init.IgusaInvariants();
    assert!(
        invariants[0] == start_inv,
        "initial invariants do not match the default hashing curve"
    );

    // Precompute a square root of -1 in Fp4.
    let i = (-Fp4::<p, D1, D2C0, D2C1>::one())
        .sqrt()
        .expect("sqrt of -1 should exist in Fp4");

    // Traverse the invariant path to recover the sequence of isogeny indices.
    let mut theta = Theta::<p, D1, D2C0, D2C1>::new(init);
    let mut indices = Vec::<u8>::new();
    for target in invariants.iter().skip(1) {
        let mut found = None;
        for m in 0usize..8usize {
            let new_null =
                compute_twoisogeny::<p, D1, D2C0, D2C1>(&theta.null, m, i);
            let ram = theta_to_rosenhain::<p, D1, D2C0, D2C1>(&new_null);
            if ram.IgusaInvariants() == *target {
                found = Some((m as u8, new_null));
                break;
            }
        }
        let (m, new_null) = found.expect("invariant path is invalid");
        indices.push(m);
        theta = Theta { null: new_null };
    }

    // Number of traversed isogenies
    let n = indices.len();
    if n == 0 {
        return String::new();
    }

    // Convert each index to an octal digit.
    indices
        .into_iter()
        .map(|m| std::char::from_digit(m as u32, 8).unwrap())
        .collect()
}

